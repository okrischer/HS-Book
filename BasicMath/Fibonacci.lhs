\subsection{Problem 2}
Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
\begin{equation*}
1, 2, 3, 5, 8, 13, 21, 34, 55, 89, \ldots
\end{equation*}

**By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms!**

\subsubsection{Recursive Implementation with Memoization}
This recursive implementation with memoization ist substancially faster then a naive recursive implementation, which would follow the mathematical rule: $fib (n) = fib (n-1) + fib (n-2)$.

\begin{code}
module Fibonacci (fibMem, fibIter, fibOpt) where

fib :: Int -> [Int] -> [Int]
fib limit memo@(n1:n2:_) 
    | next > limit = memo
    | otherwise = fib limit (next:memo) 
    where next = n1 + n2

fibMem :: Int -> Int
fibMem limit = sum $ filter even $ fib limit [1,1]
\end{code}

\subsubsection{Iterative Implementation}
While the recursive implementation was based on working with lists, the following implementation mimics an iterative solution in which the values of $(a=n-2)$ and $(b=n-1)$ and the accumulated *sum* are passed to the next recursive call:
\begin{code}
sumFib :: Int -> (Int, Int) -> Int -> Int
sumFib limit (a, b) sum 
  | c > limit = sum
  | otherwise = 
    if even c then sumFib limit (b, c) (sum + c)
    else sumFib limit (b, c) sum
  where c = a + b

fibIter limit = sumFib limit (1,1) 0
\end{code}

\subsubsection{Further Improving}
Looking at the Fibonacci sequence
\begin{equation*}
1, 1, \textbf{2}, 3, 5, \textbf{8}, 13, 21, \textbf{34}, 55, 89, \textbf{144}, \ldots
\end{equation*}
we can easily see that every third Fibonacci number is even. If this holds true for all Fibonacci numbers, we can get rid of the test for *even* like this:
\begin{code}
sumFib' :: Int -> (Int, Int, Int) -> Int -> Int
sumFib' limit (a, b, c) sum 
  | c > limit = sum
  | otherwise = sumFib' limit (a', b', c') (sum + c)
  where 
    a' = c  + b
    b' = a' + c
    c' = a' + b'

fibOpt limit = sumFib' limit (1,1,2) 0
\end{code}

**Proof of our claim, that every third Fibonacci number is even:** \
Following the rule for Fibonacci numbers, that every next number is the sum of it's two predecessors or more rigourus 
\begin{equation*}
fib (n) = fib (n-1) + fib (n-2), where fib\{0,1\} = 1
\end{equation*}
we get an *even* number if both preceeding numbers are odd, and an *odd* number if only one of the predecessors is odd. Given the starting values of $fib(n)$ with $\{1,1\}$ (both *odd*), we get '2' as the first successor, which is *even*. We now have a sequence of $\{1,1,2\}$, which is $\{odd, odd, even\}$.
Given this sequence of the first three Fibonacci numbers $\{a,b,c\}$, we can deduce that every following sequence of three numbers $\{a', b', c'\}$ must also be $\{odd, odd, even\}$: 
\begin{subequations}
$$\{a,b,c\}=\{odd,odd,even\} \implies \{a',b',c'\}=\{odd,odd,even\}$$
\begin{align}
\{a',b',c'\}&=\{(c+b), (a'+c), (a'+b')\} \label{eq:odd1} \\
&=\{(even+odd), (a'+c), (a'+b')\} \\
&=\{odd, (odd+even), (a'+b')\} \\
&=\{odd, odd, (odd+odd)\} \\
&=\{odd, odd, even\}
\end{align}
\end{subequations}
This also proofs the correctness of our algorithm (look at \eqref{eq:odd1} of the proof).

\subsubsection{Complexity Analysis}
A naive recursive solution would have a runtime complexity of at least $\mathcal{O}(n^2)$, depending on the actual implementation. The solutions `sumFibMem`, `sumFibIt` and `sumFibImp` all share a complexity of $\mathcal{O}(n)$, as they have to iterate only once through the natural numbers up to $n$. Nontheless, the iterative functions `sumFibIt` and `sumFibImp` are substancially faster, as they don't have to iterate through all (odd and even) numbers repectively an intermediate result list like `sumFibMem`.

~~~haskell
import Criterion.Main
main = defaultMain [ 
  bgroup "fibMem"
      [ bench "small"   $ whnf fibMem 4000000
      , bench "large"   $ whnf fibMem 1000000000 ],
  bgroup "fibIter"
      [ bench "small"   $ whnf fibIter 4000000
      , bench "large"   $ whnf fibIter 1000000000 ],
  bgroup "fibOpt"
      [ bench "small"   $ whnf fibOpt 4000000
      , bench "large"   $ whnf fibOpt 1000000000 ]
  ]
~~~

![benchmark-report](img/bench-fib.png)\
